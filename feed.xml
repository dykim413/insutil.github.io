<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://insutil.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://insutil.github.io/" rel="alternate" type="text/html" /><updated>2019-12-18T16:16:13+09:00</updated><id>https://insutil.github.io/feed.xml</id><title type="html">사람과 기술을 연결하는 도구 제작소</title><subtitle></subtitle><author><name>insutil</name></author><entry><title type="html">String(문자열) 완전 정복</title><link href="https://insutil.github.io/study/2019/12/15/string/" rel="alternate" type="text/html" title="String(문자열) 완전 정복" /><published>2019-12-15T00:00:00+09:00</published><updated>2019-12-15T00:00:00+09:00</updated><id>https://insutil.github.io/study/2019/12/15/string</id><content type="html" xml:base="https://insutil.github.io/study/2019/12/15/string/">&lt;h2 style=&quot;color: #005cbf&quot;&gt;안녕하세요! 신입사원 장현입니다.&lt;/h2&gt;
&lt;h6&gt;포스팅에 맛들려서 이렇게 두 번째 포스팅을 하게 되었습니다. 부디 첫 포스팅보다 더 나아지길 바라며 글을 작성해봅니다...&lt;/h6&gt;
&lt;br/&gt;
자바로 프로그래밍하게 되면 자바의 문자열을 이리저리 가공하여 쓰는 경우가 허다합니다.
&lt;br/&gt;
물론 여러분들처럼 프로그래밍 고수분들은 식은 죽 먹기로 화려하게 가공하시겠지만,
&lt;br/&gt;
저같은 초보개발자는 막상 문자열을 자르거나 추출해야하는 업무를 맡으면 땀 뻘뻘 흘리면서 구글링을 하겠죠 ㅠㅠ
&lt;br/&gt;

안그래도 초보 개발자들은 개발이 느린데 이러한 문제로 더 느려지는 것을 방지하기 위해
&lt;br/&gt;
그.래.서 제가 이렇게 문자열 완전 정복이라는 주제로 글을 쓰게 되었습니다.
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;아래는 String이 가지는 기본 메서드입니다.&lt;/h3&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;1. char charAt(int index)&lt;/h3&gt;&lt;br/&gt;
- index(정수)의 문자를 읽어냅니다.&lt;br/&gt;
예) &quot;abcde&quot;.charAt(2) 는 'c'가 읽어집니다. 0부터 시작하기 때문에 3 번째인 c가 읽어지는 것입니다.&lt;br/&gt;
반환 값은 이름에서 알다시피 char 형태로 반환이 됩니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;2. int codePointAt(int index)&lt;/h3&gt;&lt;br/&gt;
- 이것도 charAt과 마찬가지로 index로 접근하여 문자를 읽어내지만 반환값은 유니코드(int 형)로 반환합니다&lt;br/&gt;
예) &quot;abcde&quot;.codePointAt(0) 은 a의 유니코드인 97를 반환합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;3. int codePointBefore(int index)&lt;/h3&gt;&lt;br/&gt;
- 와우... codePointAt과 똑같지만, 한가지 다른 점이 있다면 codePointAt는 시작 index가 1부터 시작합니다&lt;br/&gt;
말로 이해가 잘 안된다면 아래 예를 보시고 위의 codePointAt 예를 비교하시면 이해가 잘 될 겁니다!&lt;br/&gt;
예) &quot;abcde&quot;.codePointBefore(1) 은 a의 유니코드인 97를 반환합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;4. int codePointCount(int beginIndex, int endIndex)&lt;/h3&gt;&lt;br/&gt;
- 지정한 범위안에 있는 유니코드의 갯수를 리턴합니다 (그닥 안쓰일거 같긴한데... 흠 잘 모르겠네요)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;5. int compareTo(String anotherString)&lt;/h3&gt;&lt;br/&gt;
- 2개의 두 문자열을 비교하고 int형 값을 반환합니다&lt;br/&gt;
예) x.compareTo(y)&lt;br/&gt;
1. x 와 y가 동일한 경우 0을 반환합니다.&lt;br/&gt;
2. x 가 y보다 값이 큰 경우 양수를 반환합니다.&lt;br/&gt;
3. x 가 y보다 값이 작은 경우 음수를 반환합니다.&lt;br/&gt;
부가 설명 - 맨 첫자리부터 차례대로 비교하는 특성을 가지고 있으며, 2개의 스트링을 사전적으로 비교합니다.&lt;br/&gt;
비교는 스트링내의 각각의 문자의 유니코드 값에 근거해 행해집니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;6. int compareToIgnoreCase(String str)&lt;/h3&gt;&lt;br/&gt;
- compareTo와 모든 것이 같지만, 단 하나 대소문자를 무시한다는 점에서 다릅니다.&lt;br/&gt;
예) &quot;A&quot;.compareToIgnoreCase(&quot;a&quot;); -&gt; 대소문자가 무시 되므로 반환 값은 0입니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;7. String concat(String str)&lt;/h3&gt;&lt;br/&gt;
- 2개의 문자열을 붙여주는 메서드입니다.&lt;br/&gt;
예) String str1 = &quot;안녕하세요! &quot;;&lt;br/&gt;
String str2 = &quot;장현입니다~~~&quot;;&lt;br/&gt;
String result = str1.concat(str2);&lt;br/&gt;
System.out.println(result);&lt;br/&gt;
콘솔 출력 : 안녕하세요! 장현입니다~~~&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;8. boolean contains(CharSequence s)&lt;/h3&gt;&lt;br/&gt;
- contains 메서드는 특정 문자열이 포함되어 있는 지 확인하는 기능을 제공합니다.&lt;br/&gt;
특정 문자열이 포함되어 있다면 true 를, 없다면 false 를 반환합니다.&lt;br/&gt;
예) String str = &quot;안녕하세요 장현입니다!&quot;;&lt;br/&gt;
str.contains(&quot;장현&quot;); -&gt; &quot;장현&quot;이 포함되어 있으므로 true&lt;br/&gt;
str.contains(&quot;김도영&quot;); -&gt; &quot;장현&quot;이 포함되어 있지 않으므로 false&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;9. boolean contentEquals(CharSequence cs), contentEquals(StringBuffer sb)&lt;/h3&gt;&lt;br/&gt;
- 문자열이 100% 동일해야 true 를 반환하고 하나라도 다르면 false 를 반환합니다. (문자의 순서 등..)&lt;br/&gt;
contentEquals 가 equals 와 다른 점은 equals 는 String 끼리 비교하는 것에 반해 contentEquals 는 CharSequence 또는 StringBuffer 를 인자로 받아 String 과 비교합니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
StringBuffer sb = new StringBuffer(&quot;장현&quot;);&lt;br/&gt;
str.contentEquals(sb); -&gt; 반환 값은 true&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;10. static String copyValueOf(char[] data) , copyValueOf(char[] data, int offset, int count)&lt;/h3&gt;&lt;br/&gt;
- char[] 배열에 있는 값들을 하나의 String 으로 변환합니다. 그리고 offset 과 count 를 지정해 시작 지점에서 count 만큼 잘라 낼 수도 있습니다.&lt;br/&gt;
예) char[] temp = new char[4];&lt;br/&gt;
temp[0] = '인';&lt;br/&gt;
temp[1] = '스';&lt;br/&gt;
temp[2] = '유';&lt;br/&gt;
temp[3] = '틸';&lt;br/&gt;
String.copyValueOf(temp); -&gt; &quot;인스유틸&quot;;&lt;br/&gt;
String.copyValueOf(temp, 2, 1); -&gt; &quot;유&quot;;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;11. boolean endsWith(String suffix)&lt;/h3&gt;&lt;br/&gt;
- 주어진 문자열이 파라미터로 끝나는지 체크합니다. 반환 값은 boolean 입니다.&lt;br/&gt;
예) String str = &quot;인스유틸&quot;;&lt;br/&gt;
str.endsWith(&quot;틸&quot;); -&gt; true&lt;br/&gt;
str.endsWith(&quot;유틸&quot;); -&gt; true&lt;br/&gt;
str.endsWith(&quot;인스유틸&quot;); -&gt; true&lt;br/&gt;
str.endsWith(&quot;유&quot;); -&gt; false&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;12. boolean equals(Object anObject)&lt;/h3&gt;&lt;br/&gt;
- 문자열이 주어진 파라미터와 동일한지 확인합니다. 이것 또한 boolean 이 반환됩니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
str.equals(&quot;장현&quot;); -&gt; true&lt;br/&gt;
str.equals(&quot;정채현&quot;); -&gt; false&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;13. boolean equalsIgnoreCase(String anotherString)&lt;/h3&gt;&lt;br/&gt;
- 비교대상 문자열을 대소문자 구분 없이 비교해서 동일하면 true, 그래도 다르다면 false 를 리턴합니다.&lt;br/&gt;
예) String str = &quot;abcde&quot;;&lt;br/&gt;
str.equalsIgnoreCase(&quot;aBcDE&quot;); -&gt; 대소문자를 구분하지 않으므로 true 입니다&lt;br/&gt;
str.equals(&quot;aBcDE&quot;); -&gt; equals 는 대소문자를 구분하므로 false 입니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;14. static String format(Locale l, String format, Object... args), static String format(String format, Object... args)&lt;/h3&gt;&lt;br/&gt;
- 지정된 위치에 값을 대입해서 문자열을 만들어내는 용도로 사용됩니다. 이건 예로 보는 것이 이해하기 더 빠르겠습니다.&lt;br/&gt;
예) String str = String.format(&quot;p1 : %s, p2 : %.2f&quot;, &quot;one&quot;, 1.234f); // String format 으로 변경된 값을 str 변수에 바인딩&lt;br/&gt;
System.out.println(str); -&gt; 콘솔 출력 : p1 : one, p2 : 1.23&lt;br/&gt;
해설 : %s는 스트링, %d는 숫자, %f는 실수에 대한 변경을 의미합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;h5&gt;스트링의 %s의 대표적인 기능 및 예시는 다음과 같습니다.&lt;/h5&gt;&lt;br/&gt;&lt;br/&gt;
%s : 해당 위치의 스트링을 대체합니다.&lt;br/&gt;&lt;br/&gt;
%10s : 숫자(10)만큼 문자열 좌측(+)에 공백을 채워 문자열 길이를 만듭니다. 숫자보다 문자열 길이가 긴 경우에는 그대로 보여집니다.&lt;br/&gt;
ex) &quot;장현&quot; -&gt; &quot;________장현&quot; (_는 공백)&lt;br/&gt;&lt;br/&gt;
%-10s : 숫자(10)만큼 문자열 우측(-)에 공백을 채워 문자열 길이를 만듭니다. 숫자보다 문자열 길이가 긴 경우에는 그대로 보여집니다.&lt;br/&gt;
ex) &quot;장현&quot; -&gt; &quot;장현________&quot; (_는 공백)&lt;br/&gt;&lt;br/&gt;
%10.3s : 점(.)우측에 해당하는 숫자(3) 만큼 스트링을 자른 후 숫자(10)만큼 문자열 점(.)좌측에 공백을 채워 문자열 길이를 만듭니다.&lt;br/&gt;
ex) &quot;인스유틸&quot; -&gt; &quot;_______인스유&quot;&lt;br/&gt;&lt;br/&gt;
%-10.3s : 점(.)우측에 해당하는 숫자(3) 만큼 스트링을 자른 후 숫자(10)만큼 문자열 점(.)좌측에 공백을 채워 문자열 길이를 만듭니다.&lt;br/&gt;
ex) &quot;인스유틸&quot; -&gt; &quot;인스유_______&quot;&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
스트링의 %d와 %f, 기타 %t에 대한 기능도 여러가지 있지만 추후에 더 추가하도록 하겠습니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;15. byte[] getBytes(), byte[] getBytes(Charset charset), byte[] getBytes(String charsetName)&lt;/h3&gt;&lt;br/&gt;
- 문자열을 인코딩 된 byte 형태로 넘겨줍니다. 매개변수 없이 getBytes() 메소드를 사용하면 플랫폼에 따른 default charset 을 사용합니다.&lt;br/&gt;
만일 특정 charset 을 지정할 경우 ISO-8859-1, euc-kr, utf-8 등의 charset 이 존재하는데 encoding 과 decoding 할 때 이 charset 을 맞춰서 해야합니다.&lt;br/&gt;
그러지 않을 경우 문자가 깨지는 현상이 발생하게 됩니다.&lt;br/&gt;
예) String str = &quot;Hello, 장현!&quot;; // 자바는 내부 문자열을 모두 유니코드 처리합니다.&lt;br/&gt;&lt;br/&gt;
// 유니코드 문자열을 UTF-8 캐릭터 바이트배열로 변환하여 반환&lt;br/&gt;
byte[] utf8 = str.getBytes(&quot;UTF-8&quot;); -&gt; 문자열을 utf-8로 인코딩 &lt;br/&gt;
new String(utf8, &quot;UTF-8&quot;) -&gt; 인코딩 된 바이트 배열을 다시 문자열로 디코딩 (UTF-8로 지정했으니 UTF-8로 디코딩 해야합니다. 다른 charset을 사용하면 문자가 깨집니다)&lt;br/&gt;&lt;br/&gt;
// 유니코드 문자열을 EUC-KR 캐릭터 바이트배열로 변환하여 반환&lt;br/&gt;
byte[] euckr = str.getBytes(&quot;EUC-KR&quot;);&lt;br/&gt;
new String(euckr, &quot;EUC-KR&quot;) -&gt; 인코딩 된 바이트 배열을 다시 문자열로 디코딩 (EUC-KR로 지정했으니 EUC-KR로 디코딩 해야합니다. 다른 charset을 사용하면 문자가 깨집니다)&lt;br/&gt;
&lt;br/&gt;
// 당연히 다른 바이트 배열이므로 사이즈가 다릅니다.&lt;br/&gt;
utf8.length -&gt; 14&lt;br/&gt;
euckr.length -&gt; 12&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;16. void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)&lt;/h3&gt;&lt;br/&gt;
- 주어진 문자 배열로부터 문자 배열을 추출해냅니다.&lt;br/&gt;
예) String str = &quot;인스유틸&quot;;&lt;br/&gt;
char[] dst = new char[4];&lt;br/&gt;
int srcBegin = 2; //srcBegin - 복제하기 위한 문자열에 있는 첫 번째 문자의 인덱스&lt;br/&gt;
int srcEnd = 4; //srcEnd - 복제하기 위한 문자열에 있는 마지막 문자의 다음 인덱스&lt;br/&gt;
int dstBegin = 0; // dstBegin - 여기 써있는 인덱스부터 채워 넣는다는 것입니다.&lt;br/&gt;
str.getChars(srcBegin, srcEnd, dst, dstBegin);&lt;br/&gt;
System.out.println(dst); -&gt; &quot;  유틸&quot; // dst - 복제되는 배열&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;17. boolean isEmpty()&lt;/h3&gt;&lt;br/&gt;
- 스트링이 비어있는 지 확인하는 메서드입니다. 만약 스트링 길이가 0이면 true, 그렇지 않으면 false를 반환합니다.&lt;br/&gt;
String str1 = &quot;&quot;;&lt;br/&gt;
String str2 = &quot;이수빈&quot;;&lt;br/&gt;
String str3 = null;&lt;br/&gt;
str1.isEmpty(); -&gt; true&lt;br/&gt;
str2.isEmpty(); -&gt; false&lt;br/&gt;
str3.isEmpty(); -&gt; null 값을 가지고 있는 스트링은 isEmpty 메서드를 사용하면 널포인트 익셉션이 뜨니 주의!&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;18. static String join(CharSequence delimiter, CharSequence... elements), static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)&lt;/h3&gt;&lt;br/&gt;
- 컬렉션이나 배열을 하나의 문자열로 묶어서 join 시킵니다. 예제로 보면 바로 이해하실 겁니다.&lt;br/&gt;
예) List&amp;lt;String&amp;gt; people = new ArrayList&lt;&gt;();&lt;br/&gt;
people.add(&quot;장현&quot;);&lt;br/&gt;
people.add(&quot;김도영&quot;);&lt;br/&gt;
people.add(&quot;이수빈&quot;);&lt;br/&gt;
people.add(&quot;이현승&quot;);&lt;br/&gt;
people.add(&quot;명재홍&quot;);&lt;br/&gt;
people.add(&quot;장석봉&quot;);&lt;br/&gt;
String peoples = String.join(&quot;, &quot;, people);&lt;br/&gt;
System.out.println(peoples);&lt;br/&gt;
콘솔 출력 값 : 장현, 김도영, 이수빈, 이현승, 명재홍, 장석봉&lt;br/&gt;
&lt;br/&gt;
어렵지 않습니다.&lt;br/&gt;
&lt;br/&gt;
join(&quot;추가할 문자&quot;, &quot;대상 list&quot;)&lt;br/&gt;
&lt;br/&gt;
join(&quot;추가할 문자&quot;, &quot;대상 Array&quot;)&lt;br/&gt;
&lt;br/&gt;
만약 stream의 collect() 안에서 사용하고 싶다면 아래와 같이 Collectors.joining() 을 사용하면 됩니다.&lt;br/&gt;
예) people.stream().collect(Collectors.joining(&quot;, &quot;)); -&gt; 장현, 김도영, 이수빈, 이현승, 명재홍, 장석봉&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;19. int indexOf(String str), int indexOf(String str, int fromIndex), int indexOf(int ch), int indexOf(int ch, int fromIndex)&lt;/h3&gt;&lt;br/&gt;
- 문자열 중 입력받은 문자가 있으면 해당 문자의 위치 (index) 값을 리턴하고 문자가 없으면 -1을 리턴합니다.&lt;br/&gt;
문자열 조회는 index 값 0부터 시작합니다. (왼쪽부터 읽기 시작함을 의미합니다)&lt;br/&gt;
예) String str = &quot;안녕하세요! 장현입니다!&quot;;&lt;br/&gt;
str.indexOf(&quot;요&quot;); -&gt; 4를 반환&lt;br/&gt;
str.indexOf(&quot;장현&quot;); -&gt; 7를 반환&lt;br/&gt;
str.indexOf(&quot;김한출&quot;); -&gt; -1를 반환&lt;br/&gt;
str.indexOf(&quot;!&quot;, 6); -&gt; &quot;!&quot;가 5와 12에 위치했는데 index가 6부터 시작하므로 12를 반환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;20. int lastIndexOf(String str), int lastIndexOf(String str, int fromIndex), int lastIndexOf(int ch), int lastIndexOf(int ch, int fromIndex)&lt;/h3&gt;&lt;br/&gt;
- indexOf 는 왼쪽에서부터 조회를 하기 때문에 낮은 index 값을 먼저 조회하게 됩니다.&lt;br/&gt;
이와 반대로 lastIndexOf 는 끝에서부터 조회를 합니다&lt;br/&gt;
예) String str = &quot;안녕하세요! 장현입니다!&quot;;&lt;br/&gt;
str.lastIndexOf(&quot;!&quot;); -&gt; lastIndexOf는 뒤에서부터 시작하므로 12를 반환&lt;br/&gt;
str.lastIndexOf(&quot;!&quot;, 11); -&gt; 인덱스 11부터 보겠다는 뜻이으로 5를 반환&lt;br/&gt;
str.lastIndexOf(&quot;김한출&quot;); -&gt; -1를 반환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;21. int	length()&lt;/h3&gt;&lt;br/&gt;
- 주어진 문자열의 길이를 리턴합니다&lt;br/&gt;
주의할 점은 index 값을 리턴하는 것이 아니라 실제 문장의 길이(int 형)를 리턴하는 것입니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
str.length() -&gt; 2를 반환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;22. boolean matches(String regex)&lt;/h3&gt;&lt;br/&gt;
- 파라미터에서 원하는 정규표현식을 써서 문자열에 해당하는 패턴이 있는지 알아보는 메서드입니다.&lt;br/&gt;
예) String str = &quot;안녕하세요! 장현입니다!&quot;;&lt;br/&gt;
str.matches(&quot;.*장현*&quot;); -&gt; true 입니다&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
String phonNumber = &quot;010-569-7836&quot;;&lt;br/&gt;
boolean flag = phonNumber.matches(&quot;01[06-9]-[0-9]{3,4}-[0-9]{4}&quot;);&lt;br/&gt;
System.out.println(flag); -&gt; true
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;23. String toString()&lt;/h3&gt;&lt;br/&gt;
- 문자열로 만들어 리턴하는 메서드입니다.&lt;br/&gt;
예) String str = &quot;장현&quot;;&lt;br/&gt;
str.toString(); -&gt; 문자열 &quot;장현&quot;을 리턴합니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;24. static String valueOf(Object obj), valueOf(long l), valueOf(int i), valueOf(float f), valueOf(double d),&lt;br/&gt;
valueOf(char[] data, int offset, int count), valueOf(char[] data), valueOf(char c), valueOf(boolean b)&lt;/h3&gt;&lt;br/&gt;
- toString 메서드와 비슷하나, 파라미터안에 null이 들어가면 문자열 null을 만들어서 담습니다.&lt;br/&gt;
예) String str = null;&lt;br/&gt;
String.valueOf(str); -&gt; 문자열 &quot;null&quot; 리턴, toString 이라면 널포인트 익셉션 발생합니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;25. String trim()&lt;/h3&gt;&lt;br/&gt;
- 대상 문자열의 앞 / 뒤 공백문자를 모두 제거하여 리턴해줍니다.&lt;br/&gt;
예) String str = &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;안녕하세요&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;장현입니다!&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;;&lt;br/&gt;
str.trim(); -&gt; &quot;안녕하세요&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;장현입니다!&quot;  로 만들어줍니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;26. String 	toUpperCase(), toUpperCase(Locale locale)&lt;/h3&gt;&lt;br/&gt;
- 대상 문자열을 모두 대문자로 변환합니다. 파라미터에 Locale 클래스를 인자로 받을 수도 있습니다. 인자가 없으면 디폴트 로케일로 지정됩니다&lt;br/&gt;
예) String str = &quot;Insutil&quot;;&lt;br/&gt;
str.toUpperCase(); -&gt; &quot;INSUTIL&quot; 변환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;27. String toLowerCase(), toLowerCase(Locale locale)&lt;/h3&gt;&lt;br/&gt;
- 대상 문자열을 모두 소문자로 변환합니다.&lt;br/&gt;
예) String str = &quot;Insutil&quot;;&lt;br/&gt;
str.toLowerCase() -&gt; &quot;insutil&quot; 변환&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;28. char[] toCharArray()&lt;/h3&gt;&lt;br/&gt;
- 스트링을 새로운 char 배열 형태로 변환합니다.&lt;br/&gt;
예) String str = &quot;정채현&quot;;&lt;br/&gt;
char[] charArray = str.toCharArray();&lt;br/&gt;
for(int i = 0; i &lt; charArray.length; i++) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&quot;charArray[&quot; + i + &quot;] : &quot; + charArray[i]);&lt;br/&gt;
}&lt;br/&gt;
콘솔 출력 값 :&lt;br/&gt;
charArray[0] : 정&lt;br/&gt;
charArray[1] : 채&lt;br/&gt;
charArray[2] : 현&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;29. String 	substring(int beginIndex), substring(int beginIndex, int endIndex)&lt;/h3&gt;&lt;br/&gt;
- substring 은 2가지 메서드가 있습니다. 인자 하나를 받는 substring 메서드는 시작 인덱스부터 문자열 끝까지 잘라서 반환하고,&lt;br/&gt;
인자 두 개를 받는 substring 은 문자열의 시작 부분과 끝 부분을 지정해서 그 부분만 잘라서 반환합니다. 일반적으로 많이 쓰이는 건 후자입니다.&lt;br/&gt;
예) String str = &quot;0123456789&quot;;&lt;br/&gt;
str.substring(5); -&gt; &quot;56789&quot; 를 반환 (5번 index 를 포함하여 나머지 문자열을 반환합니다)&lt;br/&gt;
str.substring(5, 8); -&gt; &quot;567&quot; 를 반환 (5번 index 를 포함하고 8번 인덱스 미만(끝 인덱스 미포함)의 문자열을 반환합니다)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;30. String[] split(String regex), String[] split(String regex, int limit)&lt;/h3&gt;&lt;br/&gt;
- 입력받은 정규표현식 또는 특정 문자를 기준으로 문자열을 나누어 배열에 저장하여 리턴합니다.&lt;br/&gt;
예) String str = &quot;010-1234-5678&quot;;&lt;br/&gt;
String[] splitNum = str.split(&quot;-&quot;);&lt;br/&gt;
String str1 = splitNum[0]; -&gt; &quot;010&quot;&lt;br/&gt;
String str2 = splitNum[1]; -&gt; &quot;1234&quot;&lt;br/&gt;
String str3 = splitNum[2]; -&gt; &quot;5678&quot;&lt;br/&gt;
&lt;br/&gt;
- 다음은 인자 값을 두 개 받는 경우입니다. 두 번째 인자 값(int 형)은 배열의 크기를 결정합니다.&lt;br/&gt;
예) String str = &quot;010-1234-5678&quot;;&lt;br/&gt;
String[] splitNum = str.split(&quot;-&quot;, 2);&lt;br/&gt;
String str1 = splitNum[0]; -&gt; &quot;010&quot;&lt;br/&gt;
String str2 = splitNum[1]; -&gt; &quot;1234-5678&quot;&lt;br/&gt;
&lt;br/&gt;
참고로 String 으로 받는 인자는 정규표현식을 인자로 받기 때문에 아래와 같은 실수를 할 수 있으므로 주의하도록 합시다!&lt;br/&gt;
예) String str = &quot;안.녕.하.세.요&quot;;&lt;br/&gt;
str.split(&quot;.&quot;); -&gt; 이렇게 하면 안됩니다! (정규식에서 .는 임의의 문자를 의미하기 때문)&lt;br/&gt;
str.split(&quot;\\.&quot;); -&gt; 이렇게 해야 여러분이 원하는 작업물이 나옵니다.&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;31. String replace(char oldChar, char newChar), String replace(CharSequence target, CharSequence replacement)&lt;/h3&gt;&lt;br/&gt;
- 자신이 바꾸고싶은 문자로 문자열을 치환시켜줍니다.&lt;br/&gt;
예) String str = &quot;인스유틸은 스타트업입니다!&quot;;&lt;br/&gt;
str = str.replace(&quot;스타트업&quot;, &quot;대기업&quot;); -&gt; &quot;인스유틸은 대기업입니다!&quot;&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;32. String 	replaceAll(String regex, String replacement)&lt;/h3&gt;&lt;br/&gt;
- replace 와 거의 비슷하나 한가지 다른 점은 replace는 첫 번째 인자 값으로 문자열을 받는 것에 반해 replaceAll은 첫 번째 인자 값으로 정규식을 받는다는 것입니다.&lt;br/&gt;
그래서 Replace는 특수문자로도 치환이 쉽지만 ReplaceAll은 정규식 특성상 특수문자로 치환이 어렵습니다.&lt;br/&gt;
예) String str = &quot;Go to the city... Boy...&quot;;&lt;br/&gt;
String rename = str.replaceAll(&quot;(?i)[b-c]&quot;, &quot;K&quot;);&lt;br/&gt;
System.out.println(rename); -&gt; 콘솔 출력 값 : Go to the Kity... Koy...&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;33. String replaceFirst(String regex, String replacement)&lt;/h3&gt;&lt;br/&gt;
- replaceFirst 메서드는 자신이 바꾸고싶은 문자열이 처음으로 해당할때만 치환시켜줍니다.&lt;br/&gt;
예) String str = &quot;장현은 인스유틸의 신입사원입니다. 인스유틸은 IT 기업입니다&quot;;&lt;br/&gt;
str = str.replaceFirst(&quot;인스유틸&quot;, &quot;9월&quot;);&lt;br/&gt;
System.out.println(str); -&gt; 콘솔 출력 값 : 장현은 9월의 신입사원입니다. 인스유틸은 IT 기업입니다&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;34. String intern()&lt;/h3&gt;&lt;br/&gt;
- 스트링 인스턴스의 문자열을 상수풀에 등록하는 메서드 입니다. 상수풀에 이미 존재하는 경우에는 해당 문자열의 주소를 반환합니다.&lt;br/&gt;
String str1 = &quot;장현&quot;;&lt;br/&gt;
String str2 = new String(&quot;장현&quot;);&lt;br/&gt;
str2 = str2.intern(); -&gt; str2에는 str1과 같은 주소값이 저장되게 된다(기존의 str2의 인스턴스는 가비지 컬렉트 됩니다)&lt;br/&gt;
if(str1 == str2) {&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println(&quot;출력 될까요?&quot;); -&gt; intern 메서드로 인해 같은 메모리 주소를 쓰므로 출력이 됩니다&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;h3&gt;35. boolean startsWith(String prefix), boolean startsWith(String prefix, int toffset)&lt;/h3&gt;&lt;br/&gt;
- 문자열을 파라미터를 기준으로 시작되는지를 확인합니다&lt;br/&gt;
예) String str = &quot;abcde&quot;;&lt;br/&gt;
System.out.println(str.startsWith(&quot;a&quot;)); -&gt; true (a부터 시작하는게 맞으므로 true 반환)&lt;br/&gt;
System.out.println(str.startsWith(&quot;ab&quot;)); -&gt; true (ab도 마찬가지)&lt;br/&gt;
System.out.println(str.startsWith(&quot;c&quot;, 2)); -&gt; true ( 인덱스 2는 c부터 시작하므로 true)&lt;br/&gt;
System.out.println(str.startsWith(&quot;c&quot;, 1)); -&gt; false ( 인덱스 1는 b부터 시작하므로 false)&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;h3&gt;36. CharSequence subSequence(int beginIndex, int endIndex)&lt;/h3&gt;&lt;br/&gt;
- 문자열을 파라미터를 기준으로 범위를 지정해서 CharSequence 형태로 반환해줍니다.&lt;br/&gt;
여기서 CharSequence 란 String, StringBuffer, StringBuilder 등 의 상위 클래스입니다.&lt;br/&gt;
CharSequence 객체내 보관하는 문자열은 같은 String 클래스와 같은 유니코드라 하더라도 &lt;br/&gt;
마크업 문자를 사용하여 변형과 가공이 가능한 문자열이란 의미로 스타일 문자 또는 연속되는 문자라고 합니다.&lt;br/&gt;
예) String str = &quot;abcde&quot;;&lt;br/&gt;
System.out.println(str.subSequence(0, 4)); -&gt; abcd 출력&lt;br/&gt;
System.out.println(str.subSequence(1, 3)); -&gt; bc 출력&lt;br/&gt;
System.out.println(str.subSequence(2, 3)); -&gt; c 출력&lt;br/&gt;
System.out.println(str.subSequence(0, str.length())); -&gt; abcde 출력&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;p style=&quot;color: #005cbf; font-size: 30px; font-weight: bolder;&quot;&gt;
regionMatches 와 offsetByCodePoints 메서드를 제외한 String 관련 메서드들을 모두 정리했습니다. &lt;br/&gt;
regionMatches 와 offsetByCodePoints는 레퍼런스가 별로 없을 뿐더러 찾아서 살펴봤는데도 이해가 잘 안되서 추가하지 않았습니다.&lt;br/&gt;
&lt;br/&gt;
그럼 이상으로, 스트링 관련 포스팅을 마치겠습니다.&lt;br/&gt;
그럼 모두 좋은 하루 보내세요!
&lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;</content><author><name>장현</name><email>daleyblind@naver.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">안녕하세요! 신입사원 장현입니다. 포스팅에 맛들려서 이렇게 두 번째 포스팅을 하게 되었습니다. 부디 첫 포스팅보다 더 나아지길 바라며 글을 작성해봅니다... 자바로 프로그래밍하게 되면 자바의 문자열을 이리저리 가공하여 쓰는 경우가 허다합니다. 물론 여러분들처럼 프로그래밍 고수분들은 식은 죽 먹기로 화려하게 가공하시겠지만, 저같은 초보개발자는 막상 문자열을 자르거나 추출해야하는 업무를 맡으면 땀 뻘뻘 흘리면서 구글링을 하겠죠 ㅠㅠ</summary></entry><entry><title type="html">자바 정규식 (Regular Expression)</title><link href="https://insutil.github.io/study/2019/12/15/regex/" rel="alternate" type="text/html" title="자바 정규식 (Regular Expression)" /><published>2019-12-15T00:00:00+09:00</published><updated>2019-12-15T00:00:00+09:00</updated><id>https://insutil.github.io/study/2019/12/15/regex</id><content type="html" xml:base="https://insutil.github.io/study/2019/12/15/regex/">&lt;p&gt;안녕하세요 인스유틸의 신입사원 장현입니다..&lt;/p&gt;
&lt;p&gt;자바 정규식은 아무리 공부해도 새롭기 때문에 이렇게 포스팅하면 여러분들께 도움이 될까 이렇게 포스팅합니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;정규식은 우리가 프로그래밍 할 때, 여러가지 이유로 많이 쓰입니다.&lt;/p&gt;
&lt;p&gt;예를 들어, 정규식은 문자열에서 특정 패턴을 찾거나, 교체 혹은 삭제하는 등 문자열을 원하는 형태로 편집하는 기능을 제공해줍니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;참고로, 대부분의 언어는 정규식을 가지고 있는데, 사용법이 조금씩 다르다는 것을 알아두세요!&lt;/p&gt;
&lt;br/&gt;

&lt;h2&gt;JAVA 의 정규식&lt;/h2&gt;
&lt;br/&gt;
&lt;b&gt;반드시 알아야 할 정규식의 기본 문법&lt;/b&gt;
&lt;br/&gt;
&lt;ul&gt;
    &lt;li&gt; ^ : 문자열의 시작&lt;/li&gt;
    &lt;li&gt; $ : 문자열의 종료&lt;/li&gt;
    &lt;li&gt; . : 임의의 한 문자 (문자의 종류를 가리지 않음. 단, \는 넣을 수 없음)&lt;/li&gt;
    &lt;li&gt; * : 앞 문자가 없을 수도, 무한정 많을 수도 있음&lt;/li&gt;
    &lt;li&gt; + : 앞 문자가 하나 이상&lt;/li&gt;
    &lt;li&gt; ? : 앞문자가 없거나 하나 있음&lt;/li&gt;
    &lt;li&gt; [ ] : 문자의 집합이나 범위를 나타내며 두 문자 사이는 - 기호로 범위를 나타낸다. [ ]내에서 ^가 선행하여 존재하면 not을 의미한다 ex) [a-z] : a~z 사이의 문자, [^bc] : b,c를 제외한 나머지&lt;/li&gt;
    &lt;li&gt; { } : 횟수 또는 범위를 나타낸다. ex) {2,3} : 2글자에서 3글자, {5} : 5글자&lt;/li&gt;
    &lt;li&gt; ( ) : 소괄호 안의 문자를 하나의 문자로 인식&lt;/li&gt;
    &lt;li&gt; | : 패턴 안에서 OR 연산을 수행할 때 사용&lt;/li&gt;
    &lt;li&gt; \s : 공백 문자&lt;/li&gt;
    &lt;li&gt; \S : 공백 문자가 아닌 나머지 문자&lt;/li&gt;
    &lt;li&gt; \w : 알파벳이나 숫자&lt;/li&gt;
    &lt;li&gt; \W : 알파벳이나 숫자를 제외한 문자&lt;/li&gt;
    &lt;li&gt; \d : 숫자 [0-9]와 동일&lt;/li&gt;
    &lt;li&gt; \D : 숫자를 제외한 모든 문자&lt;/li&gt;
    &lt;li&gt; \ : 정규표현식 역슬래시(\)는 확장 문자. 역슬래시 다음에 일반 문자가 오면 특수문자로 취급하고 역슬래시 다음에 특수문자가 오면 그 문자 자체를 의미&lt;/li&gt;
    &lt;li&gt; ?i : 앞 부분에 (?i) 라는 옵션을 넣어주면 대소문자를 구문하지 않음&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;먼저 데이터가 문자열로 넘어온다면 문자열 시작 : ^, 문자열 끝 : $로 감싸주면 되고, 문자열이 아니라면 안쓰면 됩니다&lt;/h5&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
&lt;b&gt;다음은 위의 기본 문법에 대한 예제입니다&lt;/b&gt;
&lt;br/&gt;
&lt;b&gt;Example)&lt;/b&gt;
&lt;p&gt;1. 숫자 데이터만 받기&lt;/p&gt;
&lt;b&gt;-&gt; [0-9]*&lt;/b&gt;
&lt;p&gt;1234 같이 숫자로 넘어오는 경우 체크할 수 있습니다. &lt;br/&gt;하지만 &quot;1234&quot;처럼 문자로 감싸져 넘어오는 경우까지 체크할려면 &lt;b&gt;^[0-9]*$&lt;/b&gt;로 해야합니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;2. 영문자만 받기&lt;/p&gt;
&lt;b&gt;-&gt; ^[a-zA-Z]*$&lt;/b&gt;
&lt;p&gt;[ ] 안의 패턴은 and 일 경우 ,(콤마)로 구분할 필요 없이 쭉 이어쓸 수 있습니다. (예시로, a-z(알파벳 소문자)와 A-Z(알파벳 대문자) 사이에 콤마가 없는것처럼요~)&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;3. 한글만 받기&lt;/p&gt;
&lt;b&gt;-&gt; ^[가-힣]*$&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;p&gt;4. 영어&amp;숫자만 받기&lt;/p&gt;
&lt;b&gt;-&gt; ^[a-zA-Z0-9]*$&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;p&gt;5. 이메일 형식으로 체크 : 예시) daleyblind@naver.com (ㅎㅎ 제 이메일입니다)&lt;/p&gt;
&lt;b&gt;-&gt; ^[a-zA-Z0-9]+\@[a-zA-Z]+\.[a-zA-Z]+$&lt;/b&gt;
&lt;p&gt;이메일은 살짝 복잡하므로 부가설명을 하겠습니다&lt;/p&gt;
&lt;p&gt;이메일은 일단 문자를 받으므로 ^로 시작합니다. 그리고 ID 역할을 하는 이메일 앞부분은 알파벳 대소문자와 영어 모두 올 수 있으므로 [a-zA-Z0-9]를 씁니다.
그리고 *를 쓰게되면 존재하지 않는 것도 체크하니 +를 씁니다. @나 .은 특수문자이므로 앞에 \(역슬래시)를 넣습니다.
&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;6. 핸드폰 체크 : 예시) 010-1234-5678&lt;/p&gt;
&lt;b&gt;-&gt; ^01(0|1|[6-9])\-(\d{4})\-(\d{4})$&lt;/b&gt;
&lt;br/&gt;
&lt;p&gt;7. 핸드폰 다중 체크 : 예시) 010-234-5678, 010 - 1234 - 5678, 010 1234 5678, 01012345678&lt;/p&gt;
&lt;b&gt;-&gt; ^01(0|1|[6-9])\s?\-?\s?(\d{3,4})\s?\-?\s?\d{4}$&lt;/b&gt;
&lt;p&gt;\s? : 공백이 있을 수도, 없을수도 있습니다.&lt;/p&gt;
&lt;p&gt;\-? : - 특수문자가 있을 수도, 없을 수도 있습니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;8. 주민등록번호 체크 예시) 920902-1578939&lt;/p&gt;
&lt;b&gt;\d{6}\-[1-4]\d{6}&lt;/b&gt;
&lt;p&gt;해설 : \d는 [0-9]와 같으므로 뒤에 {6}는 0~9사이의 숫자 6개를 받겠다는 의미입니다. 마지막 [1-4]\d{6} 부분은 6개의 숫자를 받겠다는 건데 [1-4]와 \d가 겹쳐져 있는데
첫글자는 1~4의 숫자를 하나 받겠다는 뜻입니다.
&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;IP 주소 체크 예시) 192.168.0.55&lt;/p&gt;
&lt;b&gt;-&gt; \d{1,3}\.\d{1,3}\d{1,3}\.\d{1,3}&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;

&lt;h3&gt;그럼 자바 정규표현식 사용법 중 하나를 채택해서, 실제 자바에서 어떻게 사용되는 지 알아보겠습니다.&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;background-color: rgb(255, 187, 0); color: rgb(255, 255, 255); font-size: 14pt;&quot;&gt;boolean result&lt;/span&gt;&lt;span style=&quot;background-color: rgb(255, 187, 0); color: rgb(255, 255, 255); font-size: 14pt;&quot;&gt;&amp;nbsp;= Pattern.matches(&quot;정규표현식&quot;, 검증데이터);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;정규표현식&quot;에는 &quot;^[0-9a-zA-Z]*$&quot;과 같은 정규표현식이 들어가고, 검증데이터는 해당 정규표현식이 맞는지 확인 할 데이터가 들어갑니다.&lt;/p&gt;
&lt;p&gt;결과는 true/false로 return 됩니다.&lt;/p&gt;
&lt;br/&gt;&lt;br/&gt;

&lt;h4&gt;자바에서 Email 검증을 위한 코드 Ex)&lt;/h4&gt;
&lt;p&gt;String regEx = &quot;^[a-zA-Z0-9]+\\@[a-zA-Z]+\\.[a-zA-Z]+$&quot;;&lt;/p&gt;
&lt;p&gt;boolean regCheck = false;&lt;/p&gt;
&lt;p&gt;regCheck = Pattern.matches(regEx, &quot;daleyblind@naver.com&quot;);&lt;/p&gt;
&lt;p&gt;if(regCheck) { // true
    &lt;br/&gt;
    // 이메일 형식이 맞는 경우
    &lt;br/&gt;
    }else { // false
    &lt;br/&gt;
    // 이메일 형식이 아닌 경우
    &lt;br/&gt;
    }
&lt;/p&gt;
&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;
&lt;h2&gt;여기까지가 기본 문법이고, 좀만 더 파고 듭시다!&lt;/h2&gt;

&lt;br/&gt;
&lt;b&gt;1. 매칭될 문자를 지정하거나, 제외하는 방법입니다.&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;table border=&quot;1&quot;&gt;
    &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;정규식&lt;/th&gt;&lt;th&gt;설명&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[abc]&lt;/td&gt;&lt;td&gt;a, b, c중 하나이면 일치 합니다.&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[^abc]&lt;/td&gt;&lt;td&gt;a, b, c를 제외한 다른 글자 이면 일치합니다.&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-zA-Z]&lt;/td&gt;&lt;td&gt;a 부터 z까지의 소문자 알파벳 이거나 A 부터 Z까지의 대문자 알파벳 중의 하나라면 일치합니다.(범위)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-d[m-p]]&lt;/td&gt;&lt;td&gt;a 부터 d까지, 또는 m 부터 p까지 중에 하나와 일치합니다: [a-dm-p] (합집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-z&amp;amp;&amp;amp;[def]]&lt;/td&gt;&lt;td&gt;d, e, f 중의 하나와 일치합니다. (교집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;[a-z&amp;amp;&amp;amp;[^bc]]&lt;/td&gt;&lt;td&gt;b와 c를 제외한 a 부터 z까지 중의 하나와 일치합니다: [ad-z] (차집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td nowrap=&quot;&quot;&gt;[a-z&amp;amp;&amp;amp;[^m-p]]&lt;/td&gt;&lt;td&gt;m부터 p 까지를 제외한, a 부터 z까지 중의 하나와 일치합니다: [a-lq-z] (차집합)&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;b&gt;2. 미리 정의된 문자를 지정하는 방법입니다.&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;table border=&quot;1&quot;&gt;
    &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;정규식&lt;/th&gt;&lt;th&gt;설명&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;.&lt;/td&gt;&lt;td&gt;임의의 문자 (라인 종결자와 일치할 수도 하지 않을 수도 있음)&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\d&lt;/td&gt;&lt;td&gt;숫자 : [0-9]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\D&lt;/td&gt;&lt;td&gt;숫자가 아닌것: [^0-9]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\s&lt;/td&gt;&lt;td&gt;공백 문자: [ \t\n\x0B\f\r]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\S&lt;/td&gt;&lt;td&gt;공백 문자가 아닌것: [^\s]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\w&lt;/td&gt;&lt;td&gt;알파벳 단어 문자(word 문자): [a-zA-Z_0-9]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;\W&lt;/td&gt;&lt;td&gt;알파벳 단어 문자가 아닌것: [^\w]&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;b&gt;3. 수량 매칭&lt;/b&gt;
&lt;br/&gt;&lt;br/&gt;
&lt;table border=&quot;1&quot;&gt;
    &lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Greedy&lt;/th&gt;&lt;th&gt;Reluctant&lt;/th&gt;&lt;th&gt;Possessive&lt;/th&gt;&lt;th&gt;의미&lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X?&lt;/td&gt;&lt;td&gt;X??&lt;/td&gt;&lt;td&gt;X?+&lt;/td&gt;&lt;td&gt;X가 없거나 한번 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X*&lt;/td&gt;&lt;td&gt;X*?&lt;/td&gt;&lt;td&gt;X*+&lt;/td&gt;&lt;td&gt;X가 없거나 한번 이상 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X+&lt;/td&gt;&lt;td&gt;X+?&lt;/td&gt;&lt;td&gt;X++&lt;/td&gt;&lt;td&gt;X가 한번 또는 여러번 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X{n}&lt;/td&gt;&lt;td&gt;X{n}?&lt;/td&gt;&lt;td&gt;X{n}+&lt;/td&gt;&lt;td&gt;&lt;p&gt;X가 정확히&amp;nbsp;n번 나옴&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X{n,}&lt;/td&gt;&lt;td&gt;X{n,}?&lt;/td&gt;&lt;td&gt;X{n,}+&lt;/td&gt;&lt;td&gt;X가 n번 이상 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;X{n,m}&lt;/td&gt;&lt;td&gt;X{n,m}?&lt;/td&gt;&lt;td&gt;X{n,m}+&lt;/td&gt;&lt;td&gt;X가 n이상 m이하로 나옴&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;
&lt;p&gt;수량매칭은 각각 세 가지 방법을 사용할 수 있는데 조금씩 차이가 있습니다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;- &lt;b&gt;Greedy&lt;/b&gt; : 매칭을 위해서 입력된 문자열 전체를 읽어서 확인하고 뒤에서 한자씩 빼면서 끝까지 확인합니다.&lt;/p&gt;
&lt;p&gt;- &lt;b&gt;Reluctant&lt;/b&gt; : 입력된 문자열에서 한글자씩 확인해 나갑니다. 마지막에 확인하는 것은 전체 문자열 입니다.&lt;/p&gt;
&lt;p&gt;- &lt;b&gt;Possessive&lt;/b&gt; : 입력된 전체 문자열을 확인합니다. Greedy와 달리 뒤에서 빼면서 확인하지 않습니다.&lt;/p&gt;
&lt;br/&gt;&lt;br/&gt;

&lt;h3 style=&quot;color: darkred;&quot;&gt;첫 포스팅인 만큼 부족함이 많이 느껴지네요... &lt;br/&gt; 더 재밌고 자세하게 알려드렸어야 하는데, 그러지 못해 아쉽고 죄송스럽습니다.&lt;br/&gt;
다음에 더 나아지도록 노력하겠습니다! &lt;br/&gt;다들 좋은 하루 되세요!
&lt;/h3&gt;</content><author><name>장현</name><email>daleyblind@naver.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">안녕하세요 인스유틸의 신입사원 장현입니다.. 자바 정규식은 아무리 공부해도 새롭기 때문에 이렇게 포스팅하면 여러분들께 도움이 될까 이렇게 포스팅합니다. 정규식은 우리가 프로그래밍 할 때, 여러가지 이유로 많이 쓰입니다. 예를 들어, 정규식은 문자열에서 특정 패턴을 찾거나, 교체 혹은 삭제하는 등 문자열을 원하는 형태로 편집하는 기능을 제공해줍니다. 참고로, 대부분의 언어는 정규식을 가지고 있는데, 사용법이 조금씩 다르다는 것을 알아두세요!</summary></entry><entry><title type="html">Generic (1)</title><link href="https://insutil.github.io/study/2019/12/14/generic/" rel="alternate" type="text/html" title="Generic (1)" /><published>2019-12-14T00:00:00+09:00</published><updated>2019-12-14T00:00:00+09:00</updated><id>https://insutil.github.io/study/2019/12/14/generic</id><content type="html" xml:base="https://insutil.github.io/study/2019/12/14/generic/">Java 를 이용해 프로그래밍을 하면서 가장 난해한것 중 하나가 Generic이 아닌가 싶다.
아직 Java 경험이 많지 않아서 일수도 있다라고 생각하고 싶지만..
실상 Generic 의 개념을 학습하고 이정도면 실무에서 사용하는데 무리가 없겠지 라는 생각에
Class, Interface, Method 등 에 Generic 을 적용하다 보면 온갖 Warning 과 Error 로
도배된 화면을 마주하게된다.

유연하고 확장가능한 Type 설곌를 위해서라도,
Java의 Api를 이해하기 위해서라도, 런타임시 언제 발생할지 모르는 타입 불일치에 대한
불안함을 조금이라도 줄이기 위해 Generic 을 더 학습해야할 필요성을 많이 느꼈다.

그래서 이참에 Generic 에 대해 다시한번 학습하고 그 내용을 정리해보고자 한다.

그 내용은 대충 이렇게 전개될 예정이다.
  ● Generic 의 개념
  ● Generic 을 제대로 활용하기 위한 주변 지식,
  ● 간단한 예제를 통한 검증

그럼 먼저 Generic 이란 무엇인지 얘기해보자.
Generic 은 Java 5 부터 추가된 개념으로 타입을 파라미터화 해서
컴파일시 구체적인 타입이 결정되도록 하는것 을 말한다.

Generic 은 Type, Method, Field 등에 사용될 수 있고,
하나 이상의 타입 매개변수(Type parameter)를 선언 하고 있는 Class 혹은 Interface를
Generic 클래스, Generic 인터페이스 라 하고 이 둘을 합쳐  Generic Type 이라 합니다.
추가로 언급하자면 Generic Type에 &lt;span class=&quot;red2&quot;&gt;실 타입 매개변수 (Actual type parameter)&lt;/span&gt;를
사용하여 인스턴스 화를 하면 이를 Parameterized type 이라고 합니다.
Parameterized type 은 타입토큰(Type Token) 에 대해 알아볼때 좀더 살펴 보겠습니다.

&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70856995-28187380-1f2a-11ea-8fdc-432d39e27a09.png&quot; /&gt;

위 그림에서 다이아몬드 연사자 라고 하는 &lt;&gt; 안의 String 이 실 타입 매개변수가 됩니다.

&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857034-eb00b100-1f2a-11ea-8217-8567800adae7.png&quot; /&gt;

그리고 위 그림은 List 인터페이스의 선언부인데 List&lt;E&gt; 에서 'E' 형식 타입 매개변수 라 합니다.

그럼 이쯤에서 왜 Generic을 써야 하는지에 대해 얘기해보겠습니다.
아래 그림을 보시죠.
&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857130-a0803400-1f2c-11ea-9f85-b4a6eecee360.png&quot;&gt;
지금 보면 해당 코드에서는 강제타입 변환이 2번 일어나게 됩니다.
  ⓐ 'hello' 라는 String 리터럴을 list.add 할때 String -&gt; Object
  ⓑ list.get(0) 으로 요소를 가져오는 부분에서 Object -&gt; String

보시면 이미 list.add 부분에서 List 라는 raw type 의 멤버 메서드 add 에 타입이 명확하지 않은 'E'
를 사용하고 있다고 경고가 뜨고 있습니다. (이런 경고를 제거하는 방법도 알아봅니다.)

아래는 Generic을 적용한 모습입니다.
&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857250-091be080-1f2e-11ea-85a5-1a7b1b1ad800.png&quot;&gt;
List 의 형식 매개변수 자리에 실 타입 매개변수 인 String 을 지정해 줌으로써
애플리케이션의 성능을 갉아먹는 불필요한 타입변환을 제거했습니다.

&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857262-6b74e100-1f2e-11ea-8868-905c68d29c99.png&quot;&gt;
그리고 실 타입 매개변수로 String이 지정된 List에 정수 100을 넣으려 하자 에러가 발생합니다.
이처럼 Generic 을 사용하면 컴파일 타임에 강력한 타입체크 를 할 수있습니다.
이를 통해 런타임에 발생할 수있는 ClassCastException 과 같은 에러를 사전에 방지 할 수 있습니다.

정리해 보면 Generic 을 사용함으로써 얻을 수 있는 장점은 크게 아래의 3가지 정도로 볼 수 있습니다.
  ⓐ 컴파일 타임에 강력한 타입체크
  ⓑ 불필요한 타입변환 제거
  ⓒ 특정 타입에 종속되지 않는 코드 작성 가능

그리고 위에서 본 그림을 설명하는 과정에서 Raw type 이 잠시 언급 되었는데
앞으로 다룰 capture 에러 회피 등 generic 을 얘기할때 빠지지 않고 등장하기 때문에
간단히 알아보고 넘어가겠습니다.
Raw type 이란 타입 파라미터가 없는 제네릭 타입을 말합니다.
아래 그림을 보시죠.

&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857506-1c7d7a80-1f33-11ea-9e0b-613cb7e2a9bb.png&quot;&gt;

그림에서 'generic' 이 바로 Raw type 변수입니다.
분명 Generics 이라는 클래스는 Generic 타입으로 정의되었지만 generics 라는 변수는
실 타입 매개변수 즉 타입 파라미터가 없이 선언되었습니다.

같은 이유로 List&lt;E&gt; 로 선언된 Generic Interface 를 List list = new ArrayList();
처럼 사용하는것 역시 Raw type 을 사용하는 것이 됩니다.

그래서 Raw type 사용에 대한 경고가 보였던 것이죠.

이왕 Raw type을 언급했으니 Raw type 사용시 반드시 숙지해야 할 점을 알아보겠습니다.
사실 가능한 Raw type은 사용하지 않는것이 좋습니다.
Raw type 자체가 Java5 이전의 하위버전 호환성을 위한 것인데 이걸 정확한 이해없이
사용하다가는 디버깅이 까다로운 런타임 에러를 만나게될 여지를 항상 내포하고 있다고 보아야 합니다.

그럼 Raw type 의 사용은 가능한 피하되 꼭 써야한다면 반드시 알아야 할것은 무엇인고 하니..
바로 Raw Type의 슈퍼 클래스는 Raw Type 이란 것입니다.
거기에 상속 받지 않은 Raw type 의 생성자, 인스턴스 메서드, 필드 역시 모두 Raw type 이란 것입니다.

즉 Raw type을 사용할시 타입 파라미터 &lt;T&gt; 를 완전히 지워버립니다.
거기에다가 Super type 타입 파라미터도 지우고 해당 클래스의 생성자, 메서드, 필드 에 정의된
모든 타입 파라미터를 지워버린 다는 것이죠... 무시무시 합니다;;

&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/70857649-f86f6880-1f35-11ea-9c89-fb5dcf0e826d.png&quot;&gt;

그러다 보니 위 그림과 같은 오류가 발생하는 것입니다.
위 그림을 보면 generic 을 Raw type 으로 선언하고 getString 라는 메서드를 호출하는데,
위에서 언급한데로 Raw type의 모든 메서드는 Raw type 입니다.
그래서 List&lt;String&gt; -&gt; List 이 됩니다.
따라서 getString이 반환하는 요소는 String 이 아닌 Object 타입으로 판정되어
String 으로 선언된 변수에 Object 타입을 대입할 수 없어서 에러가 발생하는 것이죠.

Raw type 에 대해 더 자세한 내용은 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.8&quot; target=&quot;_blank&quot;&gt;JLS 4.8&lt;/a&gt;
해당 링크를 참조 하시면 됩니다.

Raw type을 얘기하면서 타입 파라미터를 지운다는 언급을 했는데요.
이에 자연스럽게 연결해서 소거자 (Type erasure) 에 대해서도 잠시 얘기해 보겠습니다.

사실 저희가 작성하는 모든 제네릭 정보는 런타임시에 모두 제거가 됩니다.
(정확히 100% 모두는 아니구요, 몇가지 예외 case 가 있는데요,
서브가 슈퍼를 확장하면서 타입을 지정할 경우 타입정보가 소거되지 않습니다.
또 Upper bounded 에서 특정 타입의 sub 여야 한다에서 extends 뒤에 오는 슈퍼 타입의 정보도
컴파일하고 남아 런타임에도 사용 됩니다.
이에 대해서는 슈퍼타입토큰, Bounded type 을 얘기할때 언급하겠습니다.)

이렇게 소거자를 통해 타입정보를 제거하는 이유는 하위 버전과의 호환때문입니다.
C#은 호환성 따위 바로 무시해버리는 쪽을 택했는데요, Java 는 지독스러울 정도로 하위 버전과의
호환을 중요시 생각하는것 같습니다.

어쨌든 소거자에 의해 List&lt;String&gt; list = new ArrayList&lt;&gt;(); 여기서 String 과 같은
제네릭 정보는 모두 소거됩니다.

근데 여기서 그럼 어떻게 이런 프로그램이 실행되는지가 궁금하실 텐데요.
그건 컴파일러가 컴파일 타임에 제네릭 정보를 체크해서 코드에 casting 코드를 추가해놓기 때문입니다.
컴파일러.. 참 열일합니다~

여기까지 나름 학습한 내용을 적어내려 가느라 시간이 꾀나 지났는데도.. 아직 못한 얘기가 더 많은것 같습니다.

Generic 타입의 상속, Bounded type parameter, Wildcard, 타입토큰, Intersection type 등등 그리고 위에서 언급한
부분 중에서도 보충하고 싶은 부분들이 보이네요.

이번엔 Wild card 와 Bounded type parameter 를 묶어 같이 얘기해보겠습니다.
우선 Bounded Type parameter 는 경계, 제한 을 둔다는 뜻입니다.
여기엔 또 상위제한( Upper bounded ), 하위제한( Lower bounded ) 이 있습니다.
그리고 타입제한을 한개이상의 타입으로 제한하는 Intersection Type (Multi Bounded) 이 있습니다.

그리고 Wild card 는 '?' 로 나타내어 지고 알 수 없는 타입을 의미 합니다.
 ● &lt;?&gt; 모든 타입을 의미합니다, &lt;? extends Object&gt; 와 같습니다.
 ● &lt;? super 타입&gt; 명시된 타입과 그 상위 타입
 ● &lt;? extends 타입&gt; 명시된 타입과 그 하위 타입 mmmmmm</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">Java 를 이용해 프로그래밍을 하면서 가장 난해한것 중 하나가 Generic이 아닌가 싶다. 아직 Java 경험이 많지 않아서 일수도 있다라고 생각하고 싶지만.. 실상 Generic 의 개념을 학습하고 이정도면 실무에서 사용하는데 무리가 없겠지 라는 생각에 Class, Interface, Method 등 에 Generic 을 적용하다 보면 온갖 Warning 과 Error 로 도배된 화면을 마주하게된다.</summary></entry><entry><title type="html">IoC &amp;amp; DI</title><link href="https://insutil.github.io/study/2019/12/05/ioc-di/" rel="alternate" type="text/html" title="IoC &amp; DI" /><published>2019-12-05T00:00:00+09:00</published><updated>2019-12-05T00:00:00+09:00</updated><id>https://insutil.github.io/study/2019/12/05/ioc-di</id><content type="html" xml:base="https://insutil.github.io/study/2019/12/05/ioc-di/">&lt;p&gt;IoC 컨테이너 &amp; DI&lt;/p&gt;
&lt;p&gt;Iversion of Control 은 Dependency Injection 이라고도 하며,&lt;/p&gt;
&lt;p&gt;spring application 에서는 객체의 생성, 관계설정, 사용, 제거 등의 작업을 코드가 아닌&lt;/p&gt;
&lt;p&gt;독립된 컨테이너가 담당함을 뜻합니다.&lt;/p&gt;
&lt;p&gt;그래서 스프링 컨테이너를 IoC 컨테이너 라고도 합니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;스프링에선 IoC를 담당하는 컨테이너를 빈 팩토리 또는 애플리케이션 컨텍스트 라고 칭합니다.&lt;/p&gt;
&lt;p&gt;스프링 컨테이너 = IoC 컨테이너 = 빈 팩토리 = 애플리케이션 컨텍스트 라고 봐도 &lt;/p&gt;
&lt;p&gt;크게 틀리지 않지만 객체의 생성과 관계 설정 이라는 DI 관점에서 볼때는&lt;/p&gt;
&lt;p&gt;스프링 컨테이너를 빈 팩토리 라고 할 수 있고, 빈의 생성부터, 관계설정, 제거에 이르기까지&lt;/p&gt;
&lt;p&gt;빈의 life cycle 관리 에 더해 기타 엔터프라이즈 애플리케이션 개발에 필요한 기능을 추가한 것을&lt;/p&gt;
&lt;p&gt;애플리케이션 컨텍스트 라고 보시면 됩니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;BeanFactory&lt;/p&gt;
    &lt;p&gt;● 애플리케이션 컴포넌트를 관리하는 저장소&lt;/p&gt;
    &lt;p&gt;● 빈 관련 메타설정 정보를 읽어들여 빈을 구성하고 제공&lt;/p&gt;
    &lt;p&gt;● life cycle interface 지원&lt;/p&gt;

&lt;p class=&quot;magt30 magb20&quot;&gt;빈 팩토리에서 일어나는 빈의 생성, 초기화 인터페이스 와 순서는 아래의 그림을 참고 하면 됩니다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/69914170-55721580-1484-11ea-81f6-793bd0279be4.png&quot; width=&quot;600&quot;&gt;

&lt;p class=&quot;magt20&quot;&gt;위 그림에서 특히 관심이 가는것은 BeanPostProcesser 라는 빈 후처리 인터페이스 입니다.&lt;/p&gt;
&lt;p&gt;여기서 빈 후처리란 빈이 최초에 생성되고 나서 빈의 설정을 후처리 함으로써 빈의 생명주기,&lt;/p&gt;
&lt;p&gt;빈팩토리의 생명주기에 관여할 수 있게 함을 뜻합니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;흔히 코딩을 할때 Autowired 어노테이션을 이용해서 빈을 DI 받습니다.&lt;/p&gt;
&lt;p&gt;그런데 어떻게 어노테이션 하나만으로 적절한 시점에 DI 할 후보 빈을 선정하고&lt;/p&gt;
&lt;p&gt;실제 빈을 주입하는지에 대해 궁금증을 가지신 분들이 계실지 모르겠는데..&lt;/p&gt;
&lt;p&gt;바로 빈 후처리기, BeanPostProcesser 에 의 후처리 될때 빈이 주입됩니다.&lt;/p&gt;
&lt;p&gt;후처리 순서는 그림에서 보듯이 아래와 같습니다.&lt;/p&gt;
  &lt;p class=&quot;magt20&quot;&gt;ⓐ BeanPostProcesser 의 postProcessBeforeInitialization (빈 초기화 전)&lt;/p&gt;
  &lt;p&gt;ⓑ InitializingBean's afterPropertiesSet&lt;/p&gt;
  &lt;p&gt;ⓒ custom init-method&lt;/p&gt;
  &lt;p&gt;ⓓ postProcessAfterInitialization ( 빈 초기화 후 )&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;ApplicationContext&lt;/p&gt;
    &lt;p&gt;● 스프링의 IoC 컨테이너는 일반적으로 애플리케이션 컨텍스트를 칭한다.&lt;/p&gt;
    &lt;p&gt;● BeanFactory 를 확장 (자체로 빈 팩토리 기능을 한다.)&lt;/p&gt;
    &lt;p&gt;● 메시지 소스 처리 기능, 이벤트 퍼블리싱, 리소스 로딩 등의 많은 추가 기능을 가진다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;ApplicationContext 가 추가적으로 가지는 기능에 대해 자세히&lt;/p&gt;
&lt;p class=&quot;magb20&quot;&gt;알고 싶다면 스프링 레퍼런스를 참고하시면 됩니다.&lt;/p&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/55611187/69914165-4ee39e00-1484-11ea-949e-d94b7d75001d.png&quot; width=&quot;600&quot;&gt;

&lt;p class=&quot;magt30&quot;&gt;보다시피 BeanFactory를 구현하고 있고, 위에서 언급한&lt;/p&gt;
&lt;p&gt;이벤트, 메시지, 리소스로더 관련 기능등을 구현하고 있습니다.&lt;/p&gt;
&lt;p&gt;(앞으로의 포스팅을 통해서 하나하나 전부 다뤄볼 예정입니다.)&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;지금까지 IoC 컨테이너 에 대해 최대한 간략하게 정리한 내용입니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;IoC 컨테이너의 가장 기초적이고 중요한 역할은 오브젝트를 생성하고 관리하는 것입니다.&lt;/p&gt;
&lt;p&gt;즉 빈 을 관리하는것이 IoC 컨테이너의 가장 중요한 임무인 것이죠.&lt;/p&gt;
&lt;p&gt;IoC 컨테이너가 빈을 생성하고 관리하기 위해서는 POJO 클래스와 빈설정 메타정보가 필요합니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;부트 기반으로 대부분의 자바 웹 애플리케이션을 제작하는 요즘은&lt;/p&gt;
&lt;p&gt;xml과 같은 외부 설정파일을 이용하기 보다는 어노테이션 기반으로 빈 설정을 합니다.&lt;/p&gt;
&lt;p&gt;애플리케이션 컨텍스트를 저희가 코드로 생성할 일도 거의 없습니다.&lt;/p&gt;
&lt;p&gt;물론 이미 생성된 애플리케이션 컨텍스트를 활용할 수는 있습니다.&lt;/p&gt;
&lt;p&gt;지금 부터는 xml 을 이용한 빈설정, 어노테이션을 이용한 빈 설정 두방법 모두를 간단히 테스트 해보겠습니다.&lt;/p&gt;
&lt;p class=&quot;magt50&quot;&gt;단...... 다음 포스팅에서요~~ 오늘은 이만..&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">IoC 컨테이너 &amp; DI Iversion of Control 은 Dependency Injection 이라고도 하며, spring application 에서는 객체의 생성, 관계설정, 사용, 제거 등의 작업을 코드가 아닌 독립된 컨테이너가 담당함을 뜻합니다. 그래서 스프링 컨테이너를 IoC 컨테이너 라고도 합니다.</summary></entry><entry><title type="html">Blog Posting</title><link href="https://insutil.github.io/etc/2019/11/30/blog-posting/" rel="alternate" type="text/html" title="Blog Posting" /><published>2019-11-30T00:00:00+09:00</published><updated>2019-11-30T00:00:00+09:00</updated><id>https://insutil.github.io/etc/2019/11/30/blog-posting</id><content type="html" xml:base="https://insutil.github.io/etc/2019/11/30/blog-posting/">&lt;p&gt;야심차게 블로그를 만들었으나 역시나 실무에서 경험한 내용..&lt;/p&gt;
&lt;p&gt;개인적으로 학습한 내용을 또 다시 시간을 내어 포스팅 한다는게 쉽지는 않은것 같습니다.&lt;/p&gt;
&lt;p&gt;포스팅 하고 싶은 내용은 차고 넘쳐나는데 말이죠;;&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;일단 이번 포스팅은 저희 insutil 구성원 들에게 포스팅 하는 방법을 설명하는게 목적입니다.&lt;/p&gt;
&lt;p&gt;막상 블로그는 만들어 놓고 지금껏 제대로 설명을 안하고 있었네요. 쩝;&lt;/p&gt;
&lt;p&gt;주말 아침부터 혼자 일어나 씻지도 않고 부랴부랴 간단히 적어보겠습니다;&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;먼저 저희 블로그는 jekyll 을 사용해 만들어졌습니다.&lt;/p&gt;
&lt;p&gt;jekyll 에 대한 자세한 설명은 생략하구요, 그저 간단한 정적사이트 생성기 정도라고 이해하시면 됩니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;jekyll 을 설치하고 빌드해서 포스팅 하기 위해서는 ruby 를 설치 하셔야 합니다.&lt;/p&gt;
&lt;p&gt;cmd 에서 ruby -v 를 통해 확인해 봅니다. (아마 설치가 안되어 있으리라 생각됩니다.)&lt;/p&gt;
&lt;p&gt;설치가 안되어 있다면 각자의 운영체제에 맞는 ruby 를 설치하시면 됩니다. (워낙 간단하니 생략합니다.)&lt;/p&gt;

&lt;p&gt;설치가 완료되었으면 jekyll 을 설치해보죠.&lt;/p&gt;
&lt;p&gt;ruby 에서는 라이브러리를 gem 이라 하는데 이 gem 명령어를 통해 각종 패키지 설치가 가능합니다.&lt;/p&gt;
&lt;p&gt;npm 과 비슷하다고 보시면 될거 갑습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;cmd 에서 gem jekyll 을 입력합니다. (jekyll 설치)&lt;/p&gt;
&lt;p class=&quot;fwb&quot;&gt;자세한 내용은 https://jekyllrb.com/docs/ 참고 요망&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;그리고 저희회사 github repository 에서 repo 를 clone 해야겠지요.&lt;/p&gt;
&lt;p class=&quot;fwb&quot;&gt;(github username 을 알려주셔야 collaborators 추가 할 수 있으니 slack 을 통해서 알려주세요~~!!)&lt;/p&gt;

&lt;p&gt;자 그럼 이제 jekyll 을 이용해 블로그 포스팅을 위한 사전 준비는 끝이 났습니다.&lt;/p&gt;
&lt;p&gt;지금부터는 해당 글의 목적에 맞게 블로그 포스팅 을 타켓으로 해서 최대한 간략히 적겠습니다.&lt;/p&gt;

&lt;p class=&quot;fwb&quot;&gt;※ jekyll 은 정해진 포맷에 따라 글을 작성해야 하는데 간단히 나열하겠습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;ⓐ _post 폴더 하위에 YEAR-MONTH-DAY-title.html 로 파일 생성. (markdown 아님)&lt;/p&gt;
&lt;p&gt;ⓑ 모든 글은 레이아웃,카테고리 등을 포함하는 메타정보를 최상위에 적어준다.&lt;/p&gt;
&lt;p&gt;ⓒ 메타 정보 포함 작성이 끝났으면 cmd 에서 해당 폴더로 이동 'bundle exec jekyll serve' 입력&lt;/p&gt;
&lt;p&gt;ⓓ 그럼 node 처럼 local 에서 블로그를 확인할 수 있습니다. (127.0.0.1:4000)&lt;/p&gt;
&lt;p&gt;ⓔ 작성한 글이 잘 반영되었다면 이제 blog 의 remote repo 에 배포.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;위 내용중 ⓑ 메타정보에 대한 샘플이 보고 싶으시면&lt;/p&gt;
&lt;p&gt;제가 앞서 작성한 포스팅 파일을 확인 하시면 됩니다.&lt;/p&gt;
&lt;p&gt;그리고 배포는 bundle exec jekyll serve 명령어 를 실행했을때 이미 블로그 build 는 끝이 났습니다.&lt;/p&gt;
&lt;p&gt;cmd 에서 'rake publish' 입력하시면 자동으로 배포가 되도록 작업이 되어 있습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;그리고 remote repo 의 master branch 는 최종 build 한 내용물이 올라갑니다. &lt;/p&gt;
&lt;p&gt;(rake publish 명령 실행시 master branch 로 푸시합니다. 그 외에 따로 master branch 에 푸시해서는 안됩니다.)&lt;/p&gt;
&lt;p&gt;저희가 local 에서 작성하고 수정한 내용은 ( blog full source ) source branch 로 관리됩니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;여기까지 블로그 포스팅 작성을 위한 간단한 설명이었습니다.&lt;/p&gt;
&lt;p&gt;텍스트로 설명하려니 한계가 있네요, 특히 메타정보에 대해서 추가 설명이 필요할것 같은데..&lt;/p&gt;
&lt;p&gt;궁금하신 내용은 slack 을 통해서 문의주시면 됩니다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;etc&quot;]" /><summary type="html">야심차게 블로그를 만들었으나 역시나 실무에서 경험한 내용.. 개인적으로 학습한 내용을 또 다시 시간을 내어 포스팅 한다는게 쉽지는 않은것 같습니다. 포스팅 하고 싶은 내용은 차고 넘쳐나는데 말이죠;;</summary></entry><entry><title type="html">Java static</title><link href="https://insutil.github.io/study/2019/11/19/static/" rel="alternate" type="text/html" title="Java static" /><published>2019-11-19T13:00:00+09:00</published><updated>2019-11-19T13:00:00+09:00</updated><id>https://insutil.github.io/study/2019/11/19/static</id><content type="html" xml:base="https://insutil.github.io/study/2019/11/19/static/">&lt;p&gt;블로그 개설 후 제대로 된 첫 포스팅 작성입니다.&lt;/p&gt;
&lt;p&gt;첫 포스팅 이니 만큼 어떤 내용을 다뤄야 하나 고민을 하다가&lt;/p&gt;
&lt;p&gt;기초부터 잘 다지고 완전히 내것으로 만들자는 생각에 그중 처음으로&lt;/p&gt;
&lt;p class=&quot;magb30&quot;&gt;자바의 static 키워드에 대해 얘기해 볼까합니다.&lt;/p&gt;

&lt;p&gt;static 키워드는 프로그래밍 에서 '전역', '정적', 거기에 '공유' 등의 의미로 해석될 수 있습니다.&lt;/p&gt;
&lt;p&gt;static 에 대해 얘기할때 빠질 수 없는게 메모리 할당과 관련된 것인데,&lt;/p&gt;
&lt;p class=&quot;magb30&quot;&gt;java 에서 메모리를 할당 받는 방법은 크게 2가지로 볼 수 있습니다.&lt;/p&gt;

&lt;p class=&quot;fwb&quot;&gt;① 객체(인스턴스) 생성&lt;/p&gt;
&lt;p class=&quot;fwb magb30&quot;&gt;② static 사용&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;1&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69144846-9aef2400-0b0f-11ea-9d62-bd5db26dd6f8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;위 그림을 보면 객체 생성을 하지않아 메모리를 할당받지 못했기 때문에&lt;/p&gt;
&lt;p class=&quot;magb20&quot;&gt;num 이라는 변수에 접근할 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;2&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69144910-c114c400-0b0f-11ea-87de-b50284309530.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;이번 그림을 보시면 new 연산자를 통해 객체(인스턴스)를 생성.&lt;/p&gt;
&lt;p class=&quot;magb20&quot;&gt;메모리에 할당이 되었기 때문에 접근에 문제가 없는걸 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음으로 static 사용한 예를 보시죠.&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;500&quot; alt=&quot;3&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69144925-ca059580-0b0f-11ea-958f-09944e385f97.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;변수를 static 으로 선언했을 뿐인데 객체 생성 없이 class를 통해 바로 접근 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;그럼 여기서 한가지 드는 의문.. 그렇다면 굳이 객체 생성을 하지 않고&lt;/p&gt;
&lt;p&gt;가능한 모든 변수 와 메서드를 static 으로 선언해서 사용하면 되지 않을까??&lt;/p&gt;
&lt;p&gt;여기에서 static 의 장.단점이 극명하게 드러납니다.&lt;/p&gt;

&lt;p&gt;그것을 다루기 전에 JVM의 memory 구조에 대해 잠깐 얘기해 보겠습니다.&lt;/p&gt;
&lt;img width=&quot;560&quot; alt=&quot;1&quot; src=&quot;https://user-images.githubusercontent.com/55611187/69149816-a85ddb80-0b1a-11ea-9eae-d5789d314f7b.png&quot;&gt;
&lt;p&gt;사실 JVM 구조만 가지고 얘기를 해도&lt;/p&gt;
&lt;p&gt;포스팅의 모든 지면을 할애해도 부족할 만큼 언급하고 싶은 내용이 많습니다만.. &lt;/p&gt;
&lt;p&gt;static keyword 관련된 내용만 최대한 간단히 훓고 지나가겠습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;제일 먼저 개발자가 작성한 .java 파일을 compiler 가 .class (byte code)로 변환 합니다.&lt;/p&gt;
&lt;p&gt;다음으로 변환된 .class 파일을 class loder가 JVM의 메모리 영역( Runtime data area ) 에 적재합니다.&lt;/p&gt;
&lt;p&gt;메모리에 적재된 class 파일은 execution engine 에 의해 실행됩니다.&lt;/p&gt;

&lt;p&gt;그리고 보시면 Method Area (Class Area, Code Area 라고도 불립니다.) 가 보입니다.&lt;/p&gt;
&lt;p&gt;바로 이 Method Area에 Static 변수가 저장됩니다. (그 외에도 variable, method, type, constant 관련 정보도 저장.)&lt;/p&gt;
&lt;p&gt;저장되는 시점은 class 파일이 메모리에 로드되는 시점입니다.&lt;/p&gt;
&lt;p&gt;즉 데이터의 메모리 할당이 컴파일 시점에 이루어 지는 것입니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;이렇게 메모리에 로드되고 나면 런탐임 중에 필요할 때 마다 동적으로 할당 및 해제되는&lt;/p&gt;
&lt;p&gt;동적 데이터와 달리 어플리케이션의 실행 부터 종료까지 메모리에 로드된 채로 남아 있게 됩니다.&lt;/p&gt;

&lt;p&gt;이런 특징으로 인해 static 은 그 기능 과 역할이 분명히 구분되어 집니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;java에서 static 이 사용되는 영역은 변수, 메서드, 클래스가 있고 static 블럭 도 존재합니다.&lt;/p&gt;
&lt;p&gt;하나씩 짚어보겠습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;● static 변수 (클래스 변수)는&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 하나의 메모리 영역을 모든 인스턴스가 공유합니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 특정 인스턴스에 종속되지 않습니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 종합해보면 인스턴스 없이도 사용 가능하다~ 가 됩니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;● static 메서드&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 클래스 메서드 라고도 하고, 상속 클래스에서 보이지 않습니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- Override 할 수 없습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;● static 클래스&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 중첩 클래스(nested class) 에만 사용 가능합니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 상위 클래스의 멤버 필드 중에는 static 필드에만 접근 가능합니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 이런 특징은 유사 클래스를 하나로 묶어 관리와 사용을 용이하게 할 수 있습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;● static 블럭&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 클래스의 내부에 만들 수 있는 초기화 블럭입니다.&lt;/p&gt;
    &lt;p class=&quot;magl30&quot;&gt;- 클래스가 메모리에 로드 될때(초기화 될때) 단 한번 실행됩니다.&lt;/p&gt;

 &lt;p class=&quot;magt30&quot;&gt;여기까지 java 에서 static 이 사용되는 영역과 그에 따른 의미를 살펴보았습니다.&lt;/p&gt;

 &lt;p class=&quot;magt20&quot;&gt;그러면 이제 static 의 장.단점을 정리해보겠습니다.&lt;/p&gt;

 &lt;p class=&quot;magt20&quot;&gt;● 장점&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 공유되는 자원입니다. 인스턴스 생성때 마다 메모리에 올리고 초기화 하지 않고, 최초의 자원을 모든 인스턴스가 공유합니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 위와 같은 이유로 잘만 사용하면 메모리를 효율적으로 사용할 수 있습니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 인스턴스 생성없이 바로 참조하기 때문에 속도가 빠릅니다.&lt;/p&gt;

 &lt;p class=&quot;magt20&quot;&gt;● 단점&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 무분별한 사용은 메모리 오남용을 발생시킬 수 있습니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 전역적인 특징으로 인해 추론과 테스트를 힘들게 합니다.&lt;/p&gt;
       &lt;p class=&quot;magl30&quot;&gt;(공유되는 자원이므로 코드의 여러부분에서 영향을 받을 수 있게 되므로 추적이 힘들어 집니다.)&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 객체 지향의 패러다임과 맞지 않습니다.&lt;/p&gt;
       &lt;p class=&quot;magl30&quot;&gt;(static 변수는 각 객체의 데이터들이 외부로 부터 함부로 접근 할 수 없고 수정될 수 없어야 한다는 캡슐화에 위배됩니다.)&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- 오버라이딩 할 수 없는 멤버들로 인해 클래스의 확장성을 떨어뜨립니다.&lt;/p&gt;
     &lt;p class=&quot;magl30&quot;&gt;- java 와 같은 객체지향 언어들의 장점인 재사용성 을 떨어뜨리고 interface 구현에 사용할 수 없습니다.&lt;/p&gt;

&lt;p class=&quot;magt20&quot;&gt;이렇게 보면 단점이 더 많은것 같은데요.&lt;/p&gt;
&lt;p&gt;실제로 제가 본 어떤 개발자의 포스팅에서는&lt;/p&gt;
&lt;p&gt;java 에서의 static 사용을 거의 &lt;b&gt;악&lt;/b&gt;으로 규정하는 내용도 보았습니다;;&lt;/p&gt;
&lt;p&gt;하지만 분명 제대로 알고 사용한다면 단점을 최소화 하고 장점을 극대화 해서&lt;/p&gt;
&lt;p&gt;어플리케이션 성능에 도움이 될 수있습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;마지막으로 한가지만 더 언급하자면 java에서 final 변수에는 관례적으로 static 을 붙여서 사용하는 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;왜 그런가를 생각해 보면 static 이라는 녀석에 대해 또 한번 곱씹을 수 있는 부분 인데요.&lt;/p&gt;
&lt;p&gt;final 은 단한번  초기화 가능함을 뜻합니다.&lt;/p&gt;
&lt;p class=&quot;magt30&quot;&gt;다시 말해 해당 변수의 용도와 의미가 최초 한번 설정되면, 변하지 않고 고정되어야 한다는 뜻입니다.&lt;/p&gt;
&lt;p&gt;클래스의 모든 인스턴스에서 사용해야 하는 데이터고 바뀌지 않을 꺼라면, 인스턴스가 생성될때 마다&lt;/p&gt;
&lt;p&gt;메모리를 할당받고 초기화 시키지 말고, 최초 한번 메모리에 올리고 그 공간을 모든 인스턴스가 쭈~우욱~&lt;/p&gt;
&lt;p&gt;사용하게 한다면??? 매번 메모리를 할당 하는것 보다 효율적일 수 있습니다.&lt;/p&gt;
&lt;p&gt;또 final은 상수와 같은 (정확히 final = 상수 는 아닙니다.) 의미이니 동시성 문제도 없습니다.&lt;/p&gt;
&lt;p&gt;이런 이유로 멤버 final 변수는 static final로 선언하는 것이 관례가 된거 같습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;여기까지 java 의 static 에 대해 얘기해보았습니다.&lt;/p&gt;

&lt;p class=&quot;magt30&quot;&gt;두서없는 글 읽어주셔서 감사합니다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;study&quot;]" /><summary type="html">블로그 개설 후 제대로 된 첫 포스팅 작성입니다. 첫 포스팅 이니 만큼 어떤 내용을 다뤄야 하나 고민을 하다가 기초부터 잘 다지고 완전히 내것으로 만들자는 생각에 그중 처음으로 자바의 static 키워드에 대해 얘기해 볼까합니다.</summary></entry><entry><title type="html">인스유틸 블로그 첫걸음</title><link href="https://insutil.github.io/instory/study/2019/11/17/created-blog/" rel="alternate" type="text/html" title="인스유틸 블로그 첫걸음" /><published>2019-11-17T13:00:00+09:00</published><updated>2019-11-17T13:00:00+09:00</updated><id>https://insutil.github.io/instory/study/2019/11/17/created-blog</id><content type="html" xml:base="https://insutil.github.io/instory/study/2019/11/17/created-blog/">&lt;h2 class=&quot;&quot;&gt;• 동기&lt;/h2&gt;
&lt;p&gt;2019년 무더위가 한창인 8월 인스유틸 에 입사 하면서 그동안 접해보지 않았던&lt;/p&gt;
&lt;p&gt;기술로 개발을 하는 프로젝트에 곧바로 투입 되었다.&lt;/p&gt;

&lt;p&gt;덕분에? 많은 학습이 필요했고 늘 그렇듯 검색 또 검색을 하며 이런 저런 지식을&lt;/p&gt;
&lt;p&gt;머리속에 구겨넣던 중 우아한 형제들의 기술 블로그를 알게 되었다.&lt;/p&gt;
&lt;p&gt;블로그 이글 저글을 읽어 보면서 동료들과 함께 성장해 나가기 위한 그들의 모습이,&lt;/p&gt;
&lt;p&gt;기업 문화가 좋아보였다.&lt;/p&gt;

&lt;p&gt;마침 그때 나는 프로젝트를 진행하며 소통과 공유에 답답함을 많이 느끼던 중이었다.&lt;/p&gt;

&lt;p&gt;부러우면 지는거다 라는 우스갯 소리처럼 부러워만 하기보다 우리회사 도 이런 블로그를&lt;/p&gt;

&lt;p&gt;만들어 보면 좋겠다는 생각을 했고, 생각을 했으면.. 어떻게?? 그렇다 바로 실행에 옮겨야지!&lt;/p&gt;


&lt;p&gt;우아한형제들의 기술 블로그도 그러하고 요즘 github page 를 활용한 블로그 가 대세인것 같다.&lt;/p&gt;

&lt;p&gt;대세는 거스르려 하지 말고 따르자.&lt;/p&gt;

&lt;p&gt;바로 jekyll 을 활용한 블로그 생성에 돌입.&lt;/p&gt;

&lt;p&gt;잠깐씩 짬을 내서 1~2일 이면 끝날 줄 알았던 블로그 작업이 theme 를 고르는 것 부터

&lt;p&gt;plugin 연동 등을 하다 보니 갖은 삽?질 과 오기로 안되는걸 부여잡고 끙끙대고,&lt;/p&gt;

&lt;p&gt;이런저런 핑계로 미루다보니 3주정도의 시간이 걸린것 같다.&lt;/p&gt;

&lt;h2 class=&quot;magt50&quot;&gt;• 참여&lt;/h2&gt;
&lt;p&gt;이렇게 블로그는 만들어 졌지만 구성원 들이 얼마나 받아들이고 활성화가 될지는 미지수다.&lt;/p&gt;

&lt;p&gt;지금 블로그를 만들고 간단히 소회를 적어내려 가면서도 나 또한 이런 글을 적는다는게&lt;/p&gt;

&lt;p&gt;적잖이 부담이 되는게 사실이다.&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;나혼자를 위해 써내려 가는 일기가 아니라 모두와 공유하기 위한 글을 적는다는것.&lt;/p&gt;

&lt;p&gt;나름의 용기도 필요하고 의지가 동반되어야 가능하다고 생각한다.&lt;/p&gt;

&lt;p&gt;기본적으로 이 블로그는 인스유틸 구성원들이 업무를 진행하며&lt;/p&gt;

&lt;p&gt;각자가 배우고 느끼고 학습한 내용을 혼자의 기억으로 남기지 말고 기록을 함으로써&lt;/p&gt;

&lt;p&gt;함께 공유하고, 함께 배우며, 함께 성장해 나가는 그 첫걸음 이 되었으면 좋겠다.&lt;/p&gt;

&lt;p&gt;뭐든지 새로운것을 처음 받아들일때는 어느정도의 진입장벽은 있기 마련이고, 그것을 받아들이고&lt;/p&gt;

&lt;p&gt;이 블로그를 만들고자 한 취지를 공감해 주었으면 한다.&lt;/p&gt;

&lt;h2 class=&quot;magt50&quot;&gt;• 이제부터 시작&lt;/h2&gt;
&lt;p&gt;인스유틸 이라는 회사는 자신의 분야에서 20년 이상의 경력을 가진 개발자 와 신입 주니어 개발자,&lt;/p&gt;
&lt;p&gt;그리고 여기저기서 10여년간 개발을 해온 나 까지 포함해 개발자 8명, 경영지원을 해주시는 분 까지&lt;/p&gt;
&lt;p&gt;약 10명 정도로 구성된 이제 시작하는 작은 회사이다.&lt;/p&gt;

&lt;p&gt;그러다 보니 체계를 잡아나가야 할 부분들이 많다는 생각이 든다.&lt;/p&gt;
&lt;p&gt;코딩 표준화 부터, 프로젝트를 시작하고 마치기 까지 일정관리, 이슈관리,&lt;/p&gt;
&lt;p&gt;각자의 업무진행 상황을 공유하고 진행 하면서 생기는 이슈를 공론화 하고 &lt;/p&gt;
&lt;p&gt;이를 통해 끊임없이 소통하고 함께 성장해 나갈 수 있기를 바래본다.&lt;/p&gt;

&lt;p&gt;일을 더 잘하고 싶은 마음 누구나 같을것이다.&lt;/p&gt;
&lt;p&gt;좋은 구성원(개발자)은 내가 얼마나 많이 알고, 뛰어난 역량을 가졌냐가 아니라,&lt;/p&gt;
&lt;p&gt;얼마나 많은 사람이 자신으로 인해 좋은 생각을 하고 좋은 변화를 받아들이고,&lt;/p&gt;
&lt;p&gt;그로 인해 좋은 성과를 낼수 있게 하는 사람 이라고 생각한다.&lt;/p&gt;
&lt;p&gt;그를 통해 자신또한 또 한계단 성장 할 수 있으리라 본다.&lt;/p&gt;

&lt;p&gt;변화에 대해 열린 마음을 갖고 함께 성장해 나갈 인스유틸 구성원들 모두를 응원한다.&lt;/p&gt;</content><author><name>김도영</name><email>kdy6721@gmail.com</email></author><category term="[&quot;inStory&quot;, &quot;study&quot;]" /><summary type="html">• 동기 2019년 무더위가 한창인 8월 인스유틸 에 입사 하면서 그동안 접해보지 않았던 기술로 개발을 하는 프로젝트에 곧바로 투입 되었다.</summary></entry></feed>